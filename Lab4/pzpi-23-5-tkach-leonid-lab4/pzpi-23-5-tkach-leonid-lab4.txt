МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ

ЗВІТ
До лабораторної роботи №4
з дисципліни «Аналіз та рефакторинг коду»

Виконав:
ст. гр. ПЗПІ-23-5
Ткач Леонід

Прийняв:
викладач катедри ПІ
Сокорчук Ігор Петрович

Харків 2025

________________

1 ІСТОРІЯ ЗМІН

№   Дата        Версія звіту    Опис змін та виправлень
1   05.02.2025  0.1             Створено звіт

________________

2 ЗАВДАННЯ

Ознайомитися з процесом проєктування та розробки програмного забезпечення IoT-клієнта, призначеного для збору, обробки та передачі даних з пристроїв Інтернету речей до серверної частини системи. Розглянути принципи побудови архітектури IoT-клієнта з урахуванням його взаємодії з сервером, використання мережевих протоколів обміну даними та забезпечення керування підключеними пристроями.

Отримати практичні навички розробки бізнес логіки IoT-клієнта, зокрема реалізації зчитування даних із сенсорів, їх обробки та надсилання на сервер за допомогою протоколу HTTP (REST API). Розробити функції налаштування IoT-клієнта, включаючи конфігурацію параметрів підключення. Створити UML-діаграми прецедентів і діяльності, що відображають основні сценарії роботи IoT-клієнта, а також виконати перевірку працездатності реалізованого програмного забезпечення.

________________

3 ОПИС ВИКОНАНОЇ РОБОТИ

Архітектура IoT клієнта спроектована для емуляції роботи розумного горщика для рослин, що є частиною загальної системи догляду за домашніми рослинами. Система складається з програмного клієнта на мові Python, який імітує роботу мікроконтролера з підключеними сенсорами.

Для реалізації клієнтської частини було обрано мову програмування Python. Цей вибір обумовлений високою швидкістю розробки прототипу, наявністю потужних бібліотек для роботи з мережею (`requests`) та простотою інтеграції з контейнеризацією (Docker). На відміну від C++, Python дозволяє зосередитися на бізнес-логіці пристрою, мінімізуючи час на роботу з пам'яттю та низькорівневими мережевими сокетами.

IoT-клієнт виконує циклічний збір даних (додаток В.1), формуючи JSON-пакети з показниками вологості ґрунту, температури повітря та рівня освітлення. Значення генеруються випадковим чином у межах реалістичних діапазонів (наприклад, температура 15-30°C, вологість 30-80%), що дозволяє протестувати реакцію сервера на різні стани середовища.

Для демонстрації взаємодії системи була створена UML-діаграма прецедентів (Рисунок А.1). На ній відображено ключові сценарії, такі як зчитування показників сенсорів, формування пакету даних та обробка помилок з'єднання. Ця діаграма дозволяє наочно оцінити функціональні можливості клієнта.

Передача даних здійснюється через протокол HTTP методом POST на REST API серверної частини. Цей підхід забезпечує надійну доставку даних та просту інтеграцію з веб-сервером на базі FastAPI. Адреса сервера та ідентифікатор пристрою налаштовуються через файл конфігурації `config.py` (додаток В.2), який зчитує змінні оточення. Це дозволяє гнучко змінювати параметри без втручання в код, що є критично важливим при розгортанні в Docker-середовищі.

Всі процеси роботи, від генерації даних до обробки відповіді сервера, ілюструє UML-діаграма діяльності (Рисунок А.2). Вона показує логічний потік виконання програми, включаючи цикл очікування між відправками даних (інтервал за замовчуванням – 5 секунд).

Таким чином, розроблене рішення забезпечує безперервний потік телеметрії до серверної частини, дозволяючи тестувати аналітичні функції системи (прогноз вологості, статистику) в умовах, наближених до реальних.

________________

4 ВИСНОВОК

У ході лабораторної роботи було розроблено та протестовано IoT-клієнт для системи догляду за рослинами. Було обрано мову Python та бібліотеку `requests` для реалізації HTTP-взаємодії з сервером. Реалізована бізнес-логіка забезпечує генерацію реалістичних даних сенсорів та їх передачу на сервер у форматі JSON.

Система дозволяє налаштовувати адресу сервера та інтервал відправки через змінні оточення, що забезпечує гнучкість конфігурації. UML-діаграми прецедентів та діяльності наочно демонструють архітектуру та логіку роботи клієнта. Розроблене рішення успішно інтегрується з існуючим бекендом, забезпечуючи наповнення бази даних для подальшого аналізу.

________________

5 ВИКОРИСТАНІ ДЖЕРЕЛА

1. Python Requests Documentation. URL: https://requests.readthedocs.io/ (дата звернення: 05.02.2025)
2. PlantUML – офіційна документація. URL: https://plantuml.com/ (дата звернення: 05.02.2025)
3. Docker Documentation. URL: https://docs.docker.com/ (дата звернення: 05.02.2025)

________________

ДОДАТОК А
Графічні матеріали

Рисунок А.1 – Діаграма прецедентів (Use Case) IoT-пристрою

@startuml
left to right direction
actor "IoT Device (Smart Pot)" as iot

rectangle "IoT System" {
  usecase "Зчитування показників сенсорів" as UC1
  usecase "Формування пакету даних" as UC2
  usecase "Відправка даних на сервер" as UC3
  usecase "Обробка помилок з'єднання" as UC4
}

iot --> UC1
iot --> UC2
iot --> UC3
iot --> UC4
@enduml

Рисунок А.2 – Діаграма діяльності (Activity) алгоритму роботи

@startuml
start
:Load Config;
:Loop Start;
repeat
  :Generate Data;
  :Validate Data;
  :POST Request;
  if (Success?) then (Yes)
    :Log Result;
  else (No)
    :Log Error;
  endif
  :Sleep;
repeat while (True)
stop
@enduml

________________

ДОДАТОК В
Фрагменти коду

В.1 Основна логіка клієнта (main.py)

def generate_sensor_data(plant_id: int):
    """
    Generates realistic random sensor data for the plant.
    """
    return {
        "plant_id": plant_id,
        "soil_moisture": random.randint(30, 80),  # Realistic moisture %
        "temperature": round(random.uniform(15.0, 30.0), 1), # Realistic temp Celsius
        "light_level": random.randint(100, 1000) # Realistic light lux
    }

def main():
    print(f"Starting IoT Client for Device ID: {Config.DEVICE_ID}")
    # ... (setup code) ...
    while True:
        try:
            data = generate_sensor_data(Config.DEVICE_ID)
            url = f"{Config.SERVER_URL}/api/sensor/data"
            response = requests.post(url, json=data)
            
            if response.status_code == 200:
                print(f"Data sent: {data}, Status: {response.status_code}")
            else:
                print(f"Failed to send data. Status: {response.status_code}")
        # ... (error handling) ...
        time.sleep(Config.SEND_INTERVAL)


В.2 Конфігурація клієнта (config.py)

class Config:
    SERVER_URL = os.getenv("SERVER_URL", "http://backend:8000")
    DEVICE_ID = int(os.getenv("DEVICE_ID", "1"))
    SEND_INTERVAL = int(os.getenv("SEND_INTERVAL", "5"))
