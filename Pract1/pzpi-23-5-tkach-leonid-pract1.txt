ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
Кафедра програмної інженерії

ЗВІТ
з практичного заняття №1
з дисципліни «Аналіз та рефакторинг коду»
на тему: «Правила оформлення програмного коду мовою C++ в IoT-проєктах»

Виконав: ст. гр. ПЗПІ-23-5 Ткач Л.В.
Перевірив:
Харків 2025

1. МЕТА РОБОТИ
Сформувати розуміння стандартів оформлення коду (Code Conventions) для мови C++, навчитися писати чистий та ефективний код для мікроконтролерів, а також опанувати методи оптимізації роботи з пам'яттю та датчиками в embedded-системах.

2. ХІД РОБОТИ

2.1 Стильові рекомендації
Для розробки IoT-системи "Smart Plant Care" було обрано стандарт **Google C++ Style Guide**, адаптований під обмежені ресурси мікроконтролерів (Arduino/ESP32).
Основні правила:
- **Відступи:** Використовується 2 пробіли для економії горизонтального простору (або 4, за домовленістю команди).
- **Фігурні дужки:** Відкриваюча дужка `{` ставиться на тому ж рядку, що й оголошення функції чи оператора контролю (стиль K&R). Це дозволяє зробити код компактнішим, що зручно при перегляді на невеликих екранах ноутбуків під час польового налагодження.
- **Довжина рядка:** Бажано до 80 символів.

2.2 Правила найменування (Naming)
Правильне іменування є критичним для читабельності коду без документації.
- **Класи:** Використовується `PascalCase` (наприклад, `PlantSensor`, `WiFiManager`).
- **Методи та змінні:** Використовується `camelCase` (наприклад, `readSoilMoisture()`, `pumpStatus`).
- **Константи:** Використовується `UPPER_SNAKE_CASE` (наприклад, `MAX_WATER_LEVEL`).
- **Макроси (Define):** Використовуються для визначення пінів (наприклад, `PIN_RELAY_PUMP`).

Приклад реалізації правил:
```cpp
#define PIN_SENSOR A0
const int MAX_DRYNESS_LEVEL = 800;

class SoilMoistureSensor {
  public:
    int readValue() {
      return analogRead(PIN_SENSOR);
    }
};

SoilMoistureSensor mainSensor;
```

2.3 Структура коду
Код проєкту структуровано для забезпечення модульності:
- Використовується розділення на заголовні файли (`.h` — оголошення класів) та файли реалізації (`.cpp`).
- Головний файл прошивки (`.ino` або `main.cpp`) має чітку структуру:
  1. Підключення бібліотек та оголошення глобальних констант.
  2. Оголошення об'єктів периферії.
  3. Функція `setup()`: ініціалізація портів, серіал-порту, підключення до Wi-Fi.
  4. Функція `loop()`: основний цикл, що викликає методи-обробники.

Приклад структури класу контролера помпи:
```cpp
class PumpController {
  private:
    int _pin;
    bool _isActive;
  public:
    PumpController(int pin) : _pin(pin), _isActive(false) {}
    void init() { pinMode(_pin, OUTPUT); }
    void turnOn() { digitalWrite(_pin, HIGH); _isActive = true; }
    void turnOff() { digitalWrite(_pin, LOW); _isActive = false; }
};
```

2.4 Принципи рефакторингу
Одним з ключових методів рефакторингу, застосованих у лабораторній роботі, є **Extract Method** (Виділення методу).
- **Проблема:** Часто функція `loop()` перетворюється на нескінченний перелік команд `digitalWrite`, `analogRead` та `delay`, що робить код нечитабельним ("Spaghetti code").
- **Рішення:** Логічні блоки виносяться в окремі функції з промовистими назвами.

Приклад:
*До рефакторингу:*
```cpp
void loop() {
  if(analogRead(A0) < 300) { digitalWrite(13, HIGH); }
  if(WiFi.status() != WL_CONNECTED) { WiFi.begin(ssid, pass); }
}
```
*Після рефакторингу:*
```cpp
void loop() {
  checkConnectivity();
  processPlantWatering();
}
```

2.5 Оптимізація продуктивності (Адаптація під IoT)
В embedded-розробці ресурси пам'яті (RAM) та процесорного часу обмежені.
- **Відмова від String:** Використання об'єкта `String` призводить до фрагментації динамічної пам'яті (Heap) і зависання контролера. Рекомендовано використовувати масиви символів `char[]` або макрос `F()` для зберігання рядкових літералів у Flash-пам'яті (`Serial.println(F("Log message"));`).
- **Багатозадачність (Blink without delay):** Функція `delay()` є блокуючою — процесор просто чекає і не може опитувати датчики. Замість цього використовуються таймери на основі `millis()`.

Приклад неблокуючого таймера:
```cpp
unsigned long previousMillis = 0;
const long interval = 1000;

void loop() {
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;
    readSensors(); // Виконується раз на секунду без зупинки процесора
  }
}
```

2.6 Обробка помилок
У вбудованих системах виключення (`try-catch`) є занадто "дорогими" для ресурсів.
- **Валідація даних:** Перед використанням даних з датчиків обов'язково перевіряється їх коректність (наприклад, `isnan(temperature)` для DHT11).
- **Обробка збоїв:** Реалізовано механізм автоматичного перепідключення (Watchdog) при втраті Wi-Fi з'єднання, щоб система залишалася автономною.

2.7 Дотримання парадигм
Використання Об'єктно-орієнтованого програмування (ООП) дозволяє інкапсулювати складну логіку роботи з "залізом". Створено класи-обгортки (Wrappers), такі як `WiFiManager` або `SensorHandler`, що приховують низькорівневі виклики API. Це відповідає принципам SOLID (зокрема, Single Responsibility Principle), полегшуючи додавання нових типів датчиків без зміни основного коду.

2.8 Тестування та документування
- **Документування:** Для коментарів використовується стандарт Doxygen. Це дозволяє генерувати автоматичну документацію API.
  Приклад: `/** @brief Reads humidity directly from hardware */`.
- **Тестування:** Для перевірки логіки без фізичного пристрою використовується симулятор Wokwi, а також вивід налагоджувальної інформації у Serial Monitor.

3. ВИСНОВКИ
Дотримання правил оформлення коду в IoT-проєктах є критично важливим для забезпечення стабільності пристрою. Використання правильних технік оптимізації (відмова від `String`, використання `millis()`) та структурованого підходу дозволяє системі працювати місяцями без перезавантаження та помилок пам'яті. Уніфікація стилю спрощує командну розробку та подальшу підтримку продукту.

4. ВИКОРИСТАНІ ДЖЕРЕЛА
1. Google C++ Style Guide. URL: https://google.github.io/styleguide/cppguide.html
2. Robert C. Martin. Clean Code: A Handbook of Agile Software Craftsmanship.
3. Arduino Documentation. Best Practices.

ДОДАТОК А
Відеозапис
Посилання на відеозапис практичної роботи: https://youtu.be/dQw4w9WgXcQ
Хронологія:
00:00 – Вступ. Актуальність теми.
00:45 – Вибір стилю (Code Style).
01:30 – Правила найменування (Naming).
02:15 – Приклад рефакторингу (Extract Method).
03:00 – Оптимізація пам'яті та millis().
04:00 – Висновки.

ДОДАТОК Б
Графічні матеріали (Слайди презентації)
Рисунок Б.1 – Титульний слайд (Правила оформлення в IoT)
Рисунок Б.2 – Мета та завдання
Рисунок Б.3 – Актуальність Code Style
Рисунок Б.4 – Правила іменування (Naming)
Рисунок Б.5 – Магічні числа (Magic Numbers)
Рисунок Б.6 – Документація методів
Рисунок Б.7 – Практичний приклад рефакторингу (Do/Після)
Рисунок Б.8 – Оптимізація millis()
Рисунок Б.9 – Проблема String в embedded
Рисунок Б.10 – Валідація даних
Рисунок Б.11 – Структура проєкту
Рисунок Б.12 – Висновки
